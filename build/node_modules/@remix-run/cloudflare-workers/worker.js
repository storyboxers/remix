/**
 * @remix-run/cloudflare-workers v1.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var kvAssetHandler = require('@cloudflare/kv-asset-handler');
var serverRuntime = require('@remix-run/server-runtime');

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action.
 */

/**
 * Returns a request handler for the Cloudflare runtime that serves the
 * Remix SSR response.
 */
function createRequestHandler({
  build,
  getLoadContext,
  mode
}) {
  let platform = {};
  let handleRequest = serverRuntime.createRequestHandler(build, platform, mode);
  return event => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(event) : undefined;
    return handleRequest(event.request, loadContext);
  };
}
async function handleAsset(event, build, options) {
  try {
    if (process.env.NODE_ENV === "development") {
      return await kvAssetHandler.getAssetFromKV(event, {
        cacheControl: {
          bypassCache: true
        },
        ...options
      });
    }

    let cacheControl = {};
    let url = new URL(event.request.url);
    let assetpath = build.assets.url.split("/").slice(0, -1).join("/");
    let requestpath = url.pathname.split("/").slice(0, -1).join("/");

    if (requestpath.startsWith(assetpath)) {
      cacheControl = {
        bypassCache: false,
        edgeTTL: 31536000,
        browserTTL: 31536000
      };
    }

    return await kvAssetHandler.getAssetFromKV(event, {
      cacheControl,
      ...options
    });
  } catch (error) {
    if (error instanceof kvAssetHandler.MethodNotAllowedError || error instanceof kvAssetHandler.NotFoundError) {
      return null;
    }

    throw error;
  }
}
function createEventHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest = createRequestHandler({
    build,
    getLoadContext,
    mode
  });

  const handleEvent = async event => {
    let response = await handleAsset(event, build);

    if (!response) {
      response = await handleRequest(event);
    }

    return response;
  };

  return event => {
    try {
      event.respondWith(handleEvent(event));
    } catch (e) {
      if (process.env.NODE_ENV === "development") {
        event.respondWith(new Response(e.message || e.toString(), {
          status: 500
        }));
        return;
      }

      event.respondWith(new Response("Internal Error", {
        status: 500
      }));
    }
  };
}

exports.createEventHandler = createEventHandler;
exports.createRequestHandler = createRequestHandler;
exports.handleAsset = handleAsset;
