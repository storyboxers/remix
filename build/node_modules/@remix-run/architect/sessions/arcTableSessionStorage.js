/**
 * @remix-run/architect v1.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crypto = require('crypto');
var serverRuntime = require('@remix-run/server-runtime');
var arc = require('@architect/functions');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);
var arc__default = /*#__PURE__*/_interopDefaultLegacy(arc);

/**
 * Session storage using a DynamoDB table managed by Architect.
 *
 * Add the following lines to your project's `app.arc` file:
 *
 *   @tables
 *   arc-sessions
 *     _idx *String
 *     _ttl TTL
 */
function createArcTableSessionStorage({
  cookie,
  ...props
}) {
  async function getTable() {
    if (typeof props.table === "string") {
      const tables = await arc__default["default"].tables();
      return tables[props.table];
    } else {
      return props.table;
    }
  }

  return serverRuntime.createSessionStorage({
    cookie,

    async createData(data, expires) {
      const table = await getTable();

      while (true) {
        const randomBytes = crypto__namespace.randomBytes(8); // This storage manages an id space of 2^64 ids, which is far greater
        // than the maximum number of files allowed on an NTFS or ext4 volume
        // (2^32). However, the larger id space should help to avoid collisions
        // with existing ids when creating new sessions, which speeds things up.

        let id = [...randomBytes].map(x => x.toString(16).padStart(2, "0")).join("");

        if (await table.get({
          [props.idx]: id
        })) {
          continue;
        }

        let params = {
          [props.idx]: id,
          ...data
        };

        if (props.ttl) {
          params[props.ttl] = expires ? Math.round(expires.getTime() / 1000) : undefined;
        }

        await table.put(params);
        return id;
      }
    },

    async readData(id) {
      const table = await getTable();
      let data = await table.get({
        [props.idx]: id
      });

      if (data) {
        delete data[props.idx];
        if (props.ttl) delete data[props.ttl];
      }

      return data;
    },

    async updateData(id, data, expires) {
      const table = await getTable();
      let params = {
        [props.idx]: id,
        ...data
      };

      if (props.ttl) {
        params[props.ttl] = expires ? Math.round(expires.getTime() / 1000) : undefined;
      }

      await table.put(params);
    },

    async deleteData(id) {
      const table = await getTable();
      await table.delete({
        [props.idx]: id
      });
    }

  });
}

exports.createArcTableSessionStorage = createArcTableSessionStorage;
