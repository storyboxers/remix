/**
 * @remix-run/netlify v1.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var serverRuntime = require('@remix-run/server-runtime');
var node = require('@remix-run/node');

function createRequestHandler({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV
}) {
  let platform = {
    formatServerError: node.formatServerError
  };
  let handleRequest = serverRuntime.createRequestHandler(build, platform, mode);
  return async (event, context) => {
    let abortController = new node.AbortController();
    let request = createRemixRequest(event, abortController);
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(event, context) : undefined;
    let response = await handleRequest(request, loadContext);

    if (abortController.signal.aborted) {
      response.headers.set("Connection", "close");
    }

    return {
      statusCode: response.status,
      multiValueHeaders: response.headers.raw(),
      body: await response.text()
    };
  };
}
function createRemixRequest(event, abortController) {
  let url;

  if (process.env.NODE_ENV !== "development") {
    url = new URL(event.rawUrl);
  } else {
    let origin = event.headers.host;
    let rawPath = getRawPath(event);
    url = new URL(rawPath, `http://${origin}`);
  }

  let init = {
    method: event.httpMethod,
    headers: createRemixHeaders(event.multiValueHeaders),
    abortController,
    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal
  };

  if (event.httpMethod !== "GET" && event.httpMethod !== "HEAD" && event.body) {
    init.body = event.isBase64Encoded ? Buffer.from(event.body, "base64").toString() : event.body;
  }

  return new node.Request(url.href, init);
}
function createRemixHeaders(requestHeaders) {
  let headers = new node.Headers();

  for (const [key, values] of Object.entries(requestHeaders)) {
    if (values) {
      for (const value of values) {
        headers.append(key, value);
      }
    }
  }

  return headers;
} // `netlify dev` doesn't return the full url in the event.rawUrl, so we need to create it ourselves

function getRawPath(event) {
  let rawPath = event.path;
  let searchParams = new URLSearchParams();

  if (!event.multiValueQueryStringParameters) {
    return rawPath;
  }

  let paramKeys = Object.keys(event.multiValueQueryStringParameters);

  for (let key of paramKeys) {
    let values = event.multiValueQueryStringParameters[key];
    if (!values) continue;

    for (let val of values) {
      searchParams.append(key, val);
    }
  }

  let rawParams = searchParams.toString();
  if (rawParams) rawPath += `?${rawParams}`;
  return rawPath;
}

exports.createRemixHeaders = createRemixHeaders;
exports.createRemixRequest = createRemixRequest;
exports.createRequestHandler = createRequestHandler;
