/**
 * @remix-run/deno v1.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { createRequestHandler as createRequestHandler$1 } from '@remix-run/server-runtime';
import * as path from 'https://deno.land/std/path/mod.ts';
import { getType } from 'mime';

function defaultCacheControl(url, assetsPublicPath = "/build/") {
  if (url.pathname.startsWith(assetsPublicPath)) {
    return "public, max-age=31536000, immutable";
  } else {
    return "public, max-age=600";
  }
}

function createRequestHandler({
  build,
  mode,
  getLoadContext
}) {
  let remixHandler = createRequestHandler$1(build, {}, mode);
  return async request => {
    try {
      let loadContext = getLoadContext ? await getLoadContext(request) : undefined;
      return await remixHandler(request, loadContext);
    } catch (e) {
      console.error(e);
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}
async function serveStaticFiles(request, {
  cacheControl,
  publicDir = "./public",
  assetsPublicPath = "/build/"
}) {
  let url = new URL(request.url);
  let headers = new Headers();
  let contentType = getType(url.pathname);

  if (contentType) {
    headers.set("Content-Type", contentType);
  }

  if (typeof cacheControl === "function") {
    headers.set("Cache-Control", cacheControl(url));
  } else if (cacheControl) {
    headers.set("Cache-Control", cacheControl);
  } else {
    headers.set("Cache-Control", defaultCacheControl(url, assetsPublicPath));
  }

  let file = await Deno.readFile(path.join(publicDir, url.pathname));
  return new Response(file, {
    headers
  });
}
function createRequestHandlerWithStaticFiles({
  build,
  mode,
  getLoadContext,
  staticFiles = {
    publicDir: "./public",
    assetsPublicPath: "/build/"
  }
}) {
  let remixHandler = createRequestHandler({
    build,
    mode,
    getLoadContext
  });
  return async request => {
    try {
      return await serveStaticFiles(request, staticFiles);
    } catch (error) {
      if (error.code !== "EISDIR" && error.code !== "ENOENT") {
        throw error;
      }
    }

    return remixHandler(request);
  };
}

export { createRequestHandler, createRequestHandlerWithStaticFiles, serveStaticFiles };
